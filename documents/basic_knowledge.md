# 归因分析

归因分析（Attribution Analysis）是一种数据分析方法，旨在确定不同因素或维度对特定结果或绩效的贡献。对于管理者来说，归因分析有助于理解哪些因素推动了部门的效能，帮助他们做出更明智的决策，优化资源分配和战略规划。

## 归因分析的计算方法

在归因分析中，计算维度贡献率的方法可以有多种。以下是几种常见的方法：

1. **定基法（Base Method）**：
   - 定基法是一种简单的比较方法，通常用于对比某一维度在不同时间点上的变化。通过选择一个基准时间点（基期）来计算不同时间点上该维度的变化情况，从而得出该维度对结果的贡献。
   - 公式：\[ 贡献率 = \frac{(当前值 - 基准值)}{基准值} \times 100\% \]
   - 适用场景：这种方法适用于较为稳定且波动不大的数据集。

2. **边际贡献分析（Marginal Contribution Analysis）**：
   - 通过逐一增加不同的变量，观察结果变量的变化，进而确定每个变量的边际贡献。这种方法通常适用于回归分析或其他模型分析。
   - 公式：\[ 贡献率 = \frac{(增加某变量后的结果 - 原结果)}{总体结果} \]

3. **方差分析（ANOVA，Analysis of Variance）**：
   - 方差分析通过分解总方差，确定各个因素对总方差的贡献，从而评估不同因素的效应。通常用于实验设计或回归分析中。
   - 适用场景：当有多个独立变量需要分析其对因变量的影响时。

4. **因子分析（Factor Analysis）**：
   - 因子分析通过统计方法将多个变量简化为少数几个潜在因素，来解释数据的方差。该方法有助于找出隐藏在多个变量中的关键影响因素。
   - 适用场景：当数据中有多个变量相互关联，需要减少维度进行简化分析时。

5. **Shapley值归因（Shapley Value Attribution）**：
   - Shapley值是一种博弈论方法，用于计算每个因素对整体结果的公平贡献。它考虑了所有可能的因素组合，并计算各因素的边际贡献的平均值。
   - 适用场景：在机器学习模型的解释性分析中，用于评估每个特征对模型输出的贡献。

## 具体应用场景

1. **业绩评估**：管理者可以使用定基法来评估各部门在不同时期的业绩表现，了解哪个部门贡献最大，哪个部门需要改进。
2. **策略优化**：通过方差分析或因子分析，找出对部门效能影响最大的因素，帮助管理者优化策略。
3. **资源分配**：边际贡献分析有助于管理者确定资源的最佳分配方式，确保每个部门的资源分配与其对整体效能的贡献相匹配。

通过合理选择和应用上述归因分析方法，管理者可以更准确地评估各维度对部门效能的贡献，进而做出更有效的管理决策。


**（1）适用范围**
假设数据集表为

| **a_int** | **b_int** | **c_int** | **d_string** |
| --------- | --------- | --------- | ------------ |
| 1         | 2         | 3         | “啊啊啊”     |
| 4         | 5         | 6         | “哈哈哈”     |

**（2）直接表达式配置**

| **核心指标**                           | **聚合方式** |
| -------------------------------------- | ------------ |
| a_int                                  | 求和         |
| a_int + b_int                          | 求和         |
| case when a_int > 10 then 1 else 0 end | 计数         |
| d_string                               | 计数不同     |


**（3）加法配置**

| **核心指标**                                             | **聚合方式** |
| -------------------------------------------------------- | ------------ |
| sum(a_int)                                               | 聚合         |
| sum(a_int) + sum(b_int)                                  | 聚合         |
| sum(a_int) + sum(case when a_int > 10 then 1 else 0 end) | 聚合         |
| sum(a_int) + count(b_int)                                | 聚合         |
| sum(a_int) + 100                                         | 聚合         |
| count(distinct a_int) - count(a_int)                     | 聚合         |



**4）除法配置**

| **核心指标**                               | **聚合方式** |
| ------------------------------------------ | ------------ |
| sum(a_int) / sum(b_int)                    | 聚合         |
| sum(a_int) / count(b_int)                  | 聚合         |
| sum(a_int) / count(distinct b_int)         | 聚合         |
| ( sum(a_int) + sum(b_int) ) / count(c_int) | 聚合         |
| count(distinct a_int) / count(a_int)       | 聚合         |
| avg(a_int)                                 | 聚合         |

> avg(a_int) 可以视为 sum(a_int)/count(a_int)



**（5）其他复杂类型配置**

| **核心指标**                                                 | **聚合方式** |
| ------------------------------------------------------------ | ------------ |
| sum(a_int) + ( sum(b_int) / count(c_int) )                   | 聚合         |
| ( * sum(b_int) ) / count(c_int)                   | 聚合         |
| ( sum(a_int) * sum(b_int) ) / ( count(c_int) * count(c_int) ) | 聚合         |
| sum(a_int) / sum(b_int) + sum(a_int) / count(b_int)          | 聚合         |
| avg(a_int) - avg(b_int)                                      | 聚合         |
sum(a_int) 